1. המשמעות של final היא שאפשר לאתחל את המשתנה רק כאשר הוא מוגדר. ואחר כך היא אפשר לשנות אותו.

2. - אפשר להשתמש ב-super ב-constructor כדי להשתמש בconstructor של האבא (ה-class ממנו אנחנו יורשים).
- אפשר להשתמש ב-super על מנת להשתמש בפונקציות של האבא.
- אפשר להשתמש ב-super על מנת לגשת לשדות של האבא (נניח במצב שגם לאבא וגם לבן יש אותו שדה עם אותו שם ואותו סוג)

3. אי אפשר לעשות override לstatic method מכיוון שoverride עושה binding בזמן ריצה וstatic עושה binding בזמן קמפליציה.

4. אי אפשר לעשות override ל-private method מכיוון שפונקציות שהן private נראות רק ל-class שמשתמש בהן, שאר ה- classes אינם מודעים על קיומן.

5. כן, בשונה מprivate ה-class של הבן מודע שקיימת פונקציה protected אצל האבא.

6. כן, אפשר לעשות overload ל-static methods אבל בתנאי שהפרמטרים יהיו שונים (על מנת להמנע מoverride- שכמובן לא אפשרי)

7. ההבדל בין String ל-StringBuilder הוא ש-String הוא immutable , כלומר התוכן שלו לא יכול להשתנות אחרי שהוא נוצר.
לעומת StringBuilder שהוא mutable.

8. interface לא יכול להשתמש בprotected methods, וב-private הוא צריך להגדיר אותן.
בנוסף לכך, השדות של interface הן בהכרח public,static ו-final תמיד.

9. - HashSet משתמש בHashTable  בזמן שHashTree משתמש במימוש של עץ.
- HashSet מאפשר להשתמש ב-null key לעומת HashTree שזורק NullPointerExceptions.
-HashTree שומר את האיברים בצורה ממויינת בעזרת compare.
- מבחינת זמנים HashSet מציע לרוב הפעולות ביצועים בזמן O(1) כאשר HashTree מבצע אותן פעולות רק בO(logn)
נעדיף להשתמש בHashTree אם אנחנו רוצים שהאיברים שלנו יהיו בצורה ממויינת, אחרת נעדיף את HashSet שמבצע פעולות יותר מהירות.

10. HashMap מאפשר להכניס null key ומספר בלתי מוגבל של null values בלי לבדוק, לעומת HashTable שכן בודק ולא מאפשר להכניס את זה.
HashTable מסונכרן בכל קריאה, גם אם משתמשים בThread אחד רק.
כתוצאה מכך השימוש ב-HashMap יותר מהיר גם.

11. מכיוון שכאן b, i, t הם כל אחד characters, חיבור שלהם יביא את הסכום של הערך הASCII שלהם.
אם הם היו String, אז הם היו משורשרים אחד עם השני.

12. public boolean check(String s1, String s2){
        if (s1.length() != s2.length()) {
            return false;
        } else {
            char[] ArrayS1 = s1.toLowerCase().toCharArray();
            char[] ArrayS2 = s2.toLowerCase().toCharArray();
            Arrays.sort(ArrayS1);
            Arrays.sort(ArrayS2);
            return Arrays.equals(ArrayS1, ArrayS2);
        }
    }

(in java code)

13. - JVM היא מכונה וירטואלית המאפשרת למחשב להריץ תוכניות בשפת Java או שפות שיכולות להתקמפל לbytecode של Java וכך בעצם מאפשרת לתוכניות שנכתבו בשפת Java לרוץ על מגוון פלטפורמות של חומרה ומערכות הפעלה.
 - JRE יוצר את הJVM , רץ על מערכת ההפעלה ובודק שיש לנו את כל הdependencies על מנת להריץ את התוכנית Java שלנו.
-JDK הוא מימוש המאפשר ליצור תוכנית Java בפורמט שיכול לרוץ על ידי הJVM וה-JRE.
-JIT הוא מרכיב בJRE שמשפר את הביצועים של התוכנית שלנו בזמן ריצה בכך שהוא מקמפל את הbytecode של פעולה מסויימת ל-native machine code.

14. אנחנו מחליטים להשתמש בNested class שהוא static כאשר ברור שאין צורך שבכל אחד מהאובייקטים שיווצרו מהמחלקה הפנימית יהיה referecne לאובייקט מסויים מהמחלקה המכילה אותה. 
כלומר הקשר בינה לבין המחלקה שהיא מוכלת בה הוא רק בקריאה למחלקה והפונקציות שלה. 
לעומת זאת, Nested Class שהיא לא static יכולה להשתמש בכל ה-methods והשדות של המחלקה המכילה אותה (גם private)

15. New String יוצרת לנו אובייקט חדש לגמרי מסוג String (עם הערך "Test") בזמן שString = "Test" לא בהכרח יוצרת איבר חדש מכיוון שאם הוא קיים כבר, היא פשוט לוקחת אותו מה-pool (ואם נשווה בינהם אז נקבל true), לעומת 2 Strings שאם נעשה להם new ונשווה בינהם, נקבל תמיד false.
כמובן שאם אין לנו דרישות מיוחדות, עדיף להשתמש בString = "Test" וכך אנחנו חוסכים מקום.

16. אפשר לעשות את זה במידה וערך החזרה של הפונקציה אצל Derieved יורשת מערך החזרה של Base 

17.AutoCloseAble הוא interface המאפשר לנו לסגור משאבים (כמו Socket, Connection) אוטומטית כאשר אנחנו יוצאים מ-try. אותם משאבים הוגדרו כאשר נכנסו לtry על ידי האובייקט. בכך אנחנו מוודאים שחרור מהיר והמנעות מ- exeptions בעתיד.

18.Garbage Collection תהליך שדואג לשחרר זיכרון שהוקצה דינמית ואף אחד לא משתמש בו יותר. כאשר יש לנו אובייקט בלי reference , הוא הופך להיות מועמד לשחרר ע"י הGarbage collection. 
וכך המתכנת לא צריך לדאוג לשחרור זיכרון שהוא הקצה.